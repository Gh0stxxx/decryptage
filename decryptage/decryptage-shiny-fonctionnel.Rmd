---
title: "Projet MCMC et dechiffrage par BARBEREAU Pierre-Yves et BOODOO Fadil"
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### Réinitialisation de l'environnement ###
rm(list=ls())

### Librairies ###
library(stringr)
library(shiny)
library(rclipboard)
load("environnement.RData")
```
\
Ceci est un algorithme de décryptage utilisant la méthode MCMC. Cette méthode se repose dans un premier temps sur le calcul d'une matrice de sélection représentant la fréquence d'apparition de la lettre suivante sachant la lettre précédente.
L'algorithme affecte ensuite des lettres à chaque symbole du message codé : c'est la clé de décodage. Il calcule ensuite la "qualité" de ce message décodé, c'est-à-dire la probabilité que ce message décodé paraisse dans la langue décodée. L'algorithme testera la "qualité" d'un autre message, en permutant aléatoirement 2 lettres dans la clé de décodage. Il choisira ou rejettera ce nouveau message suivant l'algorithme de metropolis.
Au bout d'un certain nombre d'itérations, nous obtenons le message décodé.

\
*Exemple de la matrice de selection pour la langue anglaise :*

$$
\begin{array}{c c} &
\begin{array}{c c c c c c c} \hspace{0.01cm}a\hspace{0.3cm} & \hspace{0.6cm}b\hspace{0.5cm} & \hspace{0.5cm}...\hspace{0.3cm} & \hspace{0.5cm}z\hspace{0.6cm} & \hspace{0.9cm}.\hspace{0.3cm} & \hspace{0.9cm}...\hspace{0.3cm} & \hspace{0.4cm};\hspace{0.1cm}\\
\end{array} 
\\
\begin{array}{c c c c c c c}
a \\
b \\
... \\
z \\
. \\
...\\
;
\end{array} 
&
\left[
\begin{array}{c c c c c c c}
0,000001 & 0,014007 & 0,.. & 0,001169 & 0,000001 & 0,.. & 0,000316\\
0,075892 & 0,004422 & 0,.. & 0,000001 & 0,000001 & 0,.. & 0,000357\\
0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,..\\
0,294660 & 0,000001 & 0,.. & 0,020258 & 0 & 0,.. & 0,000001\\
0,000001 & 0,000001 & 0,.. & 0,000001 & 0,000001 & 0,.. & 0,000001\\
0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,..\\
0,000001 & 0,000001 & 0,.. & 0,000001 & 0,000001 & 0,.. & 0,000001
\end{array}
\right] 
\end{array}
$$
\
L'algorithme de Métropolis accepte le nouveau message si sa qualité est supérieure à la précédente, mais ne rejette le nouveau message que si \[ \frac{{qualité}_{nouveau \, message}}{{qualité}_{ancien \, message}} \ge  unif(1) \]  afin de permettre à l'algorithme de ne pas rester bloqué sur un extrema local.



```{r ui, echo=FALSE}
ui <- fluidPage( #interface utilisateur
  
  #tags$link(rel = 'stylesheet', type = 'text/css', href = 'progress_style.css'),
  tags$head(tags$style("#shiny-notification-panel{ top: 50% !important;left: 5% !important;margin-top: 170px !important;margin-left: -50px !important; color: blue;font-size: 20px;font-style: italic; width:100%; height:400%} .shiny-notification-close{display:none}")),
  
  rclipboardSetup(),
  h3("Cryptage"),
  
  inputPanel(
        textAreaInput("texte_a_crypter", "Texte à crypter","For that, being one o' the lowest, basest, poorest, Of this most wise rebellion, thou go'st foremost: Thou rascal, that art worst in blood to run, Lead'st first to win some vantage. But make you ready your stiff bats and clubs: Rome and her rats are at the point of battle; The one side must have bale. Hail, noble Marcius!",width = 885, height = 200)
        ),
  
  inputPanel(
        actionButton("go_cryptage", "Crypter !"),
        uiOutput("clip")
        ),

   tabsetPanel(type = "tabs",
        tabPanel("texte crypté", div(div(textOutput("texte_crypte"), class="form-control shiny-bound-input", style="width: 885px; height: 200px; color: grey"), class="shiny-input-panel"))
               ),
        h3("Decryptage"),
        h5("Collez ci dessous le texte à decrypter"),
        inputPanel(
              textAreaInput("texte_a_decrypter", "Texte à decrypter"," oac:n.:xc,'&vscov'co!c:n'cpol'z:xc,.z'z:xcfooa'z:xco c:n&zchoz:cl&z'ca','pp&ovxc:nowcso!z:c oa'hoz:-c:nowca.z$.pxc:n.:c.a:cloaz:c&vc,pooec:ocawvxcp'.e!z:c &az:c:ocl&vczoh'c?.v:.s'3c,w:ch.;'cdowca'.edcdowacz:&  c,.:zc.vec$pw,z-caoh'c.vecn'aca.:zc.a'c.:c:n'cfo&v:co c,.::p'bc:n'cov'cz&e'chwz:cn.?'c,.p'3cn.&pxcvo,p'ch.a$&wzq",width = 885, height = 200)),

h4("Attention le decryptage peut prendre plusieures minutes !"),
       inputPanel(
            
            radioButtons("language", h3("Language"),choices = list("Anglais" = 1, "Français" = 2),selected = 1),
            sliderInput("n_iterations_metropolis", "Nombre d'iterations metropolis", min=10, max=80000, value=500, step= 500),
            actionButton("go_decryptage", "Décrypter !")
                  ),
    
      tabsetPanel(type = "tabs",
            tabPanel("texte decrypté", div(div(textOutput("texte_decrypte"), class="form-control shiny-bound-input", style="width: 885px; height: 200px; color: grey"), class="shiny-input-panel"))
                  )

)
```

```{r server, echo=FALSE}
server <- function(input, output) { #server


 

lecture_texte_apprentissage <- function(nom_fichier_texte_apprentissage) { #Traitement du texte servant à l'apprentissage
  texte_apprentissage <- toString(readLines(nom_fichier_texte_apprentissage,encoding="UTF-8"))
  texte_apprentissage <- str_to_lower(texte_apprentissage)
  texte_apprentissage <- gsub("\\s{2,}"," ", texte_apprentissage)
  texte_apprentissage <- gsub(" ,","", texte_apprentissage)
  texte_apprentissage <- gsub("\n","", texte_apprentissage)
  return(texte_apprentissage)
}


extraction_alphabets_du_texte <- function(texte) { #extraction des caracteres de l'alphabet du texte
  alphabets = c()
  n=str_length(texte)
  
  for (i in 1:n ){
    alphabet = str_sub(texte,i,i)
    
    if (!alphabet %in% alphabets)
        alphabets = c(alphabets,alphabet)
    }
  return(alphabets)
}


traitement_des_caracteres_speciaux <- function(alphabets) { #traitement des caractères spéciaux
  alphabets_avec_speciaux = c()
  for (alphabet in alphabets) {
    if ( str_detect( alphabet , "[\\+\\*\\?\\^\\$\\.\\[\\]\\{\\}\\(\\)\\|\\/]" ) ) {
      alphabets_avec_speciaux = c(alphabets_avec_speciaux, str_c("\\",alphabet))
    }
    else {
      alphabets_avec_speciaux = c(alphabets_avec_speciaux, alphabet)
    }
  }
  return(alphabets_avec_speciaux)
}


cryptage <- function(texte,alphabets) { #cryptage du texte
  texte=str_to_lower(texte)
  alphabets_crypte = sample(alphabets)
  texte_crypte = ""
  for( i in 1:(str_length(texte)) ) {
    lettre_texte = str_sub(texte,i,i)
    texte_crypte = str_c( texte_crypte , alphabets[ which( lettre_texte == alphabets_crypte) ] )
  }
  return(texte_crypte)
}


calcul_matrice_apprentissage <- function(texte, alphabets) { #calcul de la matrice d'apprentissage
  probabilites = c()
  matrice_col_row_names = alphabets
  alphabets = traitement_des_caracteres_speciaux(alphabets)
  
  for (i in 1: length(alphabets) ) {
    premiere_lettre = alphabets[i]
    occurences_premier_lettre = as.vector(str_extract_all(texte,str_c(premiere_lettre,'.'))[[1]])
    
    for (j in 1: length(alphabets) ) {
      seconde_lettre = alphabets[j]
      premiere_et_seconde_lettre = str_c(premiere_lettre,seconde_lettre)
      nombre_occurences_premiere_et_seconde_lettre = sum(occurences_premier_lettre == premiere_et_seconde_lettre)
      probabilite_premiere_et_seconde_lettre = nombre_occurences_premiere_et_seconde_lettre/length(occurences_premier_lettre)
      probabilites = c(probabilites, probabilite_premiere_et_seconde_lettre)
      
    }
  }
  for(s in 1:length(probabilites)){
     if(probabilites[s]==0){probabilites[s]=10**(-6)}
      }
  matrice_apprentissage = matrix( probabilites, nrow = length(alphabets), byrow = TRUE, dimnames = list(matrice_col_row_names, matrice_col_row_names) )
  return(matrice_apprentissage)
}


qualite=function(texte,matrice_apprentissage){ #fonction calculant la qualité du texte 
  texte=str_to_lower(texte)
  n=str_length(texte)
  qualite=0
  for(i in 1:(n-1)){
    p=matrice_apprentissage[str_sub(texte,i,i),str_sub(texte,i+1,i+1)]
    qualite=qualite+log(p) #nous avons pris le log pour permettre à un double de stocker toute l'étendue de la valeur renvoyée.
    
  }
  qualite
}

##permutation_alphabet = function(alphabets) 
textevoisin=function(texte,frequences_lettres){ #calcule un texte voisin aléatoire par permutation de deux lettres
  lettres_ordonnees=names(frequences_lettres)
  alphabet_du_texte=extraction_alphabets_du_texte(texte)
  indice1=sample(length(alphabet_du_texte),size=1)
  indice2=sample(1:length(lettres_ordonnees),size=1,prob=frequences_lettres/sum(frequences_lettres))
  paire_indice=c(indice1,indice2)
  paire_indice
  texte_voisin=''
  for(i in 1:str_length(texte)){
    if(str_sub(texte,i,i)==alphabet_du_texte[paire_indice[1]]){
      texte_voisin=str_c(texte_voisin,toString(lettres_ordonnees[paire_indice[2]]))
      
    }
     else if(str_sub(texte,i,i)==lettres_ordonnees[paire_indice[2]]){
      texte_voisin=str_c(texte_voisin,alphabet_du_texte[paire_indice[1]])
     }
    else{
      texte_voisin=str_c(texte_voisin,str_sub(texte,i,i))
    }
  }
  return(texte_voisin)
}






metropolis=function(texte_voisin,texte_crypte,qualite,matrice_apprentissage,frequences_lettres){
  probanew=qualite(texte_voisin,matrice_apprentissage)
  probaold=qualite(texte_crypte,matrice_apprentissage)
  if (probanew-probaold >= 0) { return(texte_voisin) } 
  else if (runif(1) <= exp(probanew - probaold)) { return(texte_voisin) } 
  else { return(texte_crypte) }
}

frequencelettres=function(texte,extraction_alphabets_du_texte){
  alphabets=extraction_alphabets_du_texte(texte)
  frequence_lettres=c(numeric(length(alphabets)))
  n=str_length(texte)
    for(i in 1:n){
      if(i%%10000==0){print(paste(i,"/",n))}
      for(j in 1:length(alphabets)){
        if(str_sub(texte,i,i)==alphabets[j]){frequence_lettres[j]=frequence_lettres[j]+1}
      }
    }
  names(frequence_lettres) = alphabets
  frequence_lettres=sort(frequence_lettres,decreasing = TRUE)
}

textecrypte2=function(texte_crypte, frequence_lettres,frequence_lettres_cryptees){ #decryptage par fréquence utilisé avant metropolis pour accelerer le resultat
  lettres_cryptees_ordonnees=names(frequence_lettres_cryptees)
  lettres_ordonnees=names(frequence_lettres)
  texte_crypte2 = ''
  for(i in 1:str_length(texte_crypte)){
    for(j in 1:length(lettres_cryptees_ordonnees)){
      if(str_sub(texte_crypte,i,i)==lettres_cryptees_ordonnees[j]){
        texte_crypte2=str_c(texte_crypte2,lettres_ordonnees[j])
      }
    }
  }
  return(toString(texte_crypte2))
}





##apprentissage


#La fonction suivante genère un fichier .Rdata contenant l'environnement généré à l'aide du fichier d'apprentissage mon_fichier_texte_apprentissage
generer_rdata=function(nom_fichier_texte_apprentissage,lecture_texte_apprentissage,extraction_alphabets_du_texte,calcul_matrice_apprentissage,frequencelettres,traitement_des_caracteres_speciaux){
  texte_apprentissage = lecture_texte_apprentissage(nom_fichier_texte_apprentissage)
  alphabets = extraction_alphabets_du_texte(texte_apprentissage)
  matrice_apprentissage = calcul_matrice_apprentissage(texte_apprentissage,alphabets)
  frequences_lettres=frequencelettres(texte_apprentissage,extraction_alphabets_du_texte)
  lettres_ordonnees=names(frequences_lettres)
  lettres_ordonnees = traitement_des_caracteres_speciaux(lettres_ordonnees)
  #for(i in (length(lettres_ordonnees)-k):length(lettres_ordonnees)){
  #  texte_apprentissage <- gsub(lettres_ordonnees[i],"", texte_apprentissage)
  #}
  #alphabets = extraction_alphabets_du_texte(texte_apprentissage)
  #matrice_apprentissage = calcul_matrice_apprentissage(texte_apprentissage,alphabets)
  #frequences_lettres=frequencelettres(texte_apprentissage,extraction_alphabets_du_texte)
  nom_fichier_sortie=paste(nom_fichier_texte_apprentissage,".Rdata")
  print(paste("le fichier \"",nom_fichier_sortie,"\" a été créé dans le repertoire courant"))
  return(save(matrice_apprentissage,alphabets,frequences_lettres,lettres_ordonnees,file=nom_fichier_sortie))
}


##Execution






cryptage_reactive=eventReactive(c(input$go_cryptage),{ #cryptage reactif
  
  input$language
  langue=input$language
   if(langue==2){
      load("francais.Rdata")
      
    }
    
    else if (langue==1){
     load("anglais.RData")
    }
  texte=input$texte_a_crypter
  texte=str_to_lower(texte)

  texte_crypte = cryptage(texte,alphabets)
  texte_crypte
})




decryptage_reactive=eventReactive(c(input$go_decryptage),{ #decryptage reactif
  input$language
    langue=input$language
    if(langue==2){
      load("francais.Rdata")
      
    }
    
    else if (langue==1){
      load("anglais.RData")
    }

  texte_crypte=input$texte_a_decrypter
  texte_crypte_initial=texte_crypte
  v=c()
  texte_crypte=str_to_lower(texte_crypte)
  frequences_lettres_cryptees=frequencelettres(texte_crypte,extraction_alphabets_du_texte)
  texte_crypte=textecrypte2(texte_crypte,frequences_lettres,frequences_lettres_cryptees)
  best=list("",-Inf)
  v=c()
  n_iterations_metropolis=input$n_iterations_metropolis


  withProgress(message = 'Decryptage', value = 0, { #barre de progression
    for(l in 1:n_iterations_metropolis){ #iterations de metropolis
  
      texte_voisin=textevoisin(texte_crypte,frequences_lettres)
        incProgress(1/n_iterations_metropolis, detail = paste("itération ", l,"/",n_iterations_metropolis,"Courant : ","\n",texte_voisin,"\n\n")) #progression barre de progression

      texte_crypte=metropolis(texte_voisin,texte_crypte,qualite,matrice_apprentissage,frequences_lettres)
      p=qualite(texte_crypte,matrice_apprentissage)

    
      if(p>best[[2]]){best=list(texte_crypte,p)} #sauvegarde du meilleur resultat
      if(l%%100==0){ # print une iteration sur 100 afin d'observer le travail effectué dans la boucle (en mode console uniquement)
        cat("n = ",l,"\n\n")
        cat("Courant  : ",p,"\n",texte_crypte,"\n\n")
        cat("meilleur : ",best[[2]],"\n",best[[1]],"\n","\n\n\n")
        v=c(v,texte_crypte)
      }
    }
  })
  return(best) #retourne le meilleur resultat 
}) #end decryptage_reactive


   


output$texte_crypte <- renderText({ #output texte crypte
  cryptage_reactive()
  })


 output$texte_decrypte <- renderText({ #output texte decrypte
   decryptage_reactive()[[1]]
   })


output$clip <- renderUI({ #output bouton copier le texte crypte dans le presse-papier 
    rclipButton("clipbtn", "Copier", cryptage_reactive(), icon("clipboard"))
  })





} #end server



# Run the application 
shinyApp(ui = ui, server = server,   options = list(width= 950, height = 800)) #lancement de shinyapp
```
