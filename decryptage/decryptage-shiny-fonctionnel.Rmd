---
title: "Projet MCMC et dechiffrage \n BARBEREAU Pierre-Yves et BOODOO Fadil"
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### Réinitialisation de l'environnement ###
rm(list=ls())

### Librairies ###
library(stringr)
library(shiny)
library(rclipboard)
load("environnement.RData")
```
\
Ceci est un algorithme de décryptage utilisant la méthode MCMC. Cette méthode se repose dans un premier temps sur le calcul d'une matrice de sélection représentant la fréquence d'apparition de la lettre suivante sachant la lettre précédente.
L'algorithme affecte ensuite des lettres à chaque symbole du message codé : c'est la clé de décodage. Il calcule ensuite la "qualité" de ce message décodé, c'est-à-dire la probabilité que ce message décodé paraisse dans la langue décodée. L'algorithme testera la "qualité" d'un autre message, en permutant aléatoirement 2 lettres dans la clé de décodage. Il choisira ou rejettera ce nouveau message suivant l'algorithme de metropolis.
Au bout d'un certain nombre d'itérations, nous obtenons le message décodé.

\
*Exemple de la matrice de selection pour la langue anglaise :*

$$
\begin{array}{c c} &
\begin{array}{c c c c c c c} \hspace{0.01cm}a\hspace{0.3cm} & \hspace{0.6cm}b\hspace{0.5cm} & \hspace{0.5cm}...\hspace{0.3cm} & \hspace{0.5cm}z\hspace{0.6cm} & \hspace{0.9cm}.\hspace{0.3cm} & \hspace{0.9cm}...\hspace{0.3cm} & \hspace{0.4cm};\hspace{0.1cm}\\
\end{array} 
\\
\begin{array}{c c c c c c c}
a \\
b \\
... \\
z \\
. \\
...\\
;
\end{array} 
&
\left[
\begin{array}{c c c c c c c}
0,000001 & 0,014007 & 0,.. & 0,001169 & 0,000001 & 0,.. & 0,000316\\
0,075892 & 0,004422 & 0,.. & 0,000001 & 0,000001 & 0,.. & 0,000357\\
0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,..\\
0,294660 & 0,000001 & 0,.. & 0,020258 & 0 & 0,.. & 0,000001\\
0,000001 & 0,000001 & 0,.. & 0,000001 & 0,000001 & 0,.. & 0,000001\\
0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,.. & 0,..\\
0,000001 & 0,000001 & 0,.. & 0,000001 & 0,000001 & 0,.. & 0,000001
\end{array}
\right] 
\end{array}
$$
\
L'algorithme de Métropolis accepte le nouveau message si sa qualité est supérieure à la précédente, mais ne rejette le nouveau message que si \[ \frac{{qualité}_{nouveau \, message}}{{qualité}_{ancien \, message}} \ge  unif(1) \]  afin de permettre à l'algorithme de ne pas rester bloqué sur un minimal local.



```{r ui, echo=FALSE}
ui <- fluidPage(
  
  rclipboardSetup(),
  h3("Cryptage"),
  
  inputPanel(
        fileInput("file", "Choose a file", multiple = FALSE, accept = NULL,
  width = NULL, buttonLabel = "Browse...",
  placeholder = "No file selected"),
  h4(textOutput("file_ok"), type="text/css", style = "color:#337ab7; position: relative; top: 32px; left: 0px;")
    ),
  
  inputPanel(
        textAreaInput("texte_a_crypter", "Texte à crypter","For that, being one o' the lowest, basest, poorest, Of this most wise rebellion, thou go'st foremost: Thou rascal, that art worst in blood to run, Lead'st first to win some vantage. But make you ready your stiff bats and clubs: Rome and her rats are at the point of battle; The one side must have bale. Hail, noble Marcius!",width = 885, height = 200)
        
    ),
  
   inputPanel(
  actionButton("go_cryptage", "Crypter !"),
        uiOutput("clip")
),

   tabsetPanel(type = "tabs",
               tabPanel("texte crypté", div(div(textOutput("texte_crypte"), class="form-control shiny-bound-input", style="width: 885px; height: 200px; color: grey"), class="shiny-input-panel"))
               ),
h3("Decryptage"),
  inputPanel(
        textAreaInput("texte_a_decrypter", "Texte à decrypter"," oac:n.:xc,'&vscov'co!c:n'cpol'z:xc,.z'z:xcfooa'z:xco c:n&zchoz:cl&z'ca','pp&ovxc:nowcso!z:c oa'hoz:-c:nowca.z$.pxc:n.:c.a:cloaz:c&vc,pooec:ocawvxcp'.e!z:c &az:c:ocl&vczoh'c?.v:.s'3c,w:ch.;'cdowca'.edcdowacz:&  c,.:zc.vec$pw,z-caoh'c.vecn'aca.:zc.a'c.:c:n'cfo&v:co c,.::p'bc:n'cov'cz&e'chwz:cn.?'c,.p'3cn.&pxcvo,p'ch.a$&wzq",width = 885, height = 200)),

h3("attention le decryptage peut prendre plusieures minutes"),
  inputPanel(
         sliderInput("n_iterations_metropolis", "Nombre d'iterations metropolis", min=10, max=80000, value=500, step= 500),
        actionButton("go_decryptage", "Décrypter !"),
        radioButtons("language", h3("Language"),
                     choices = list("Anglais" = 1, "Français" = 2),
                     selected = 1)
    ),
    
    tabsetPanel(type = "tabs",
                tabPanel("texte decrypté", div(div(textOutput("texte_decrypte"), class="form-control shiny-bound-input", style="width: 885px; height: 200px; color: grey"), class="shiny-input-panel"))
        ),
h3("Historique des itérations"),
tabsetPanel(type = "tabs",
                tabPanel("Historique", verbatimTextOutput("texte_courant",placeholder = TRUE))
        )

)
```

```{r server, echo=FALSE}
server <- function(input, output) {


 

lecture_texte_apprentissage <- function(nom_fichier_texte_apprentissage) {
  texte_apprentissage <- toString(readLines(nom_fichier_texte_apprentissage,encoding="UTF-8"))
  texte_apprentissage <- str_to_lower(texte_apprentissage)
  texte_apprentissage <- gsub("\\s{2,}"," ", texte_apprentissage)
  texte_apprentissage <- gsub(" ,","", texte_apprentissage)
  texte_apprentissage <- gsub("\n","", texte_apprentissage)
  return(texte_apprentissage)
}


extraction_alphabets_du_texte <- function(texte) {
  alphabets = c()
  n=str_length(texte)
  
  for (i in 1:n ){
    alphabet = str_sub(texte,i,i)
    
    if (!alphabet %in% alphabets)
      alphabets = c(alphabets,alphabet)
  }
  return(alphabets)
}


traitement_des_caracteres_speciaux <- function(alphabets) {
  alphabets_avec_speciaux = c()
  for (alphabet in alphabets) {
    if ( str_detect( alphabet , "[\\+\\*\\?\\^\\$\\.\\[\\]\\{\\}\\(\\)\\|\\/]" ) ) {
      alphabets_avec_speciaux = c(alphabets_avec_speciaux, str_c("\\",alphabet))
    } else {
      alphabets_avec_speciaux = c(alphabets_avec_speciaux, alphabet)
    }
  }
  return(alphabets_avec_speciaux)
}


cryptage <- function(texte,alphabets) {
  texte=str_to_lower(texte)
  alphabets_crypte = sample(alphabets)
  texte_crypte = ""
  for( i in 1:(str_length(texte)) ) {
    lettre_texte = str_sub(texte,i,i)
    texte_crypte = str_c( texte_crypte , alphabets[ which( lettre_texte == alphabets_crypte) ] )
  }
  return(texte_crypte)
}


calcul_matrice_apprentissage <- function(texte, alphabets) {
  probabilites = c()
  matrice_col_row_names = alphabets
  alphabets = traitement_des_caracteres_speciaux(alphabets)
  
  for (i in 1: length(alphabets) ) {
    premiere_lettre = alphabets[i]
    occurences_premier_lettre = as.vector(str_extract_all(texte,str_c(premiere_lettre,'.'))[[1]])
    
    for (j in 1: length(alphabets) ) {
      seconde_lettre = alphabets[j]
      premiere_et_seconde_lettre = str_c(premiere_lettre,seconde_lettre)
      nombre_occurences_premiere_et_seconde_lettre = sum(occurences_premier_lettre == premiere_et_seconde_lettre)
      probabilite_premiere_et_seconde_lettre = nombre_occurences_premiere_et_seconde_lettre/length(occurences_premier_lettre)
      probabilites = c(probabilites, probabilite_premiere_et_seconde_lettre)
      
    }
  }
      for(s in 1:length(probabilites)){
        if(probabilites[s]==0){probabilites[s]=10**(-6)}
      }
  matrice_apprentissage = matrix( probabilites, nrow = length(alphabets), byrow = TRUE, dimnames = list(matrice_col_row_names, matrice_col_row_names) )
  return(matrice_apprentissage)
}


qualite=function(texte,matrice_apprentissage){
  texte=str_to_lower(texte)
  n=str_length(texte)
  qualite=0
  for(i in 1:(n-1)){
    p=matrice_apprentissage[str_sub(texte,i,i),str_sub(texte,i+1,i+1)]
    qualite=qualite+log(p)
    
  }
  qualite
}

##permutation_alphabet = function(alphabets) 
textevoisin=function(texte,frequences_lettres){
  lettres_ordonnees=names(frequences_lettres)
  alphabet_du_texte=extraction_alphabets_du_texte(texte)
  indice1=sample(length(alphabet_du_texte),size=1)
  indice2=sample(1:length(lettres_ordonnees),size=1,prob=frequences_lettres/sum(frequences_lettres))
  paire_indice=c(indice1,indice2)
  paire_indice
  texte_voisin=''
  for(i in 1:str_length(texte)){
    if(str_sub(texte,i,i)==alphabet_du_texte[paire_indice[1]]){
      texte_voisin=str_c(texte_voisin,toString(lettres_ordonnees[paire_indice[2]]))
      
    }
     else if(str_sub(texte,i,i)==lettres_ordonnees[paire_indice[2]]){
      texte_voisin=str_c(texte_voisin,alphabet_du_texte[paire_indice[1]])
     }
    else{
      texte_voisin=str_c(texte_voisin,str_sub(texte,i,i))
    }
  }
  return(texte_voisin)
}


textevoisin_alternatif=function(texte,alphabets){
  paire_indice=sample(length(alphabets),size=2)
  texte_voisin=''
  for(i in 1:str_length(texte)){
    if(str_sub(texte,i,i)==alphabets[paire_indice[1]]){
      texte_voisin=str_c(texte_voisin,alphabets[paire_indice[2]])
      
    }
     else if(str_sub(texte,i,i)==alphabets[paire_indice[2]]){
      texte_voisin=str_c(texte_voisin,alphabets[paire_indice[1]])
     }
    else{
      texte_voisin=str_c(texte_voisin,str_sub(texte,i,i))
    }
  }
  return(texte_voisin)
}



metropolis=function(texte_voisin,texte_crypte,qualite,matrice_apprentissage,frequences_lettres){
  probanew=qualite(texte_voisin,matrice_apprentissage)
  probaold=qualite(texte_crypte,matrice_apprentissage)
if (probanew-probaold >= 0) { return(texte_voisin) } 
else if (runif(1) <= exp(probanew - probaold)) { return(texte_voisin) } 
else { return(texte_crypte) }
}

frequencelettres=function(texte,extraction_alphabets_du_texte){
  alphabets=extraction_alphabets_du_texte(texte)
frequence_lettres=c(numeric(length(alphabets)))
  n=str_length(texte)
    for(i in 1:n){
      if(i%%10000==0){print(paste(i,"/",n))}
      for(j in 1:length(alphabets)){
        if(str_sub(texte,i,i)==alphabets[j]){frequence_lettres[j]=frequence_lettres[j]+1}
      }
    }
  names(frequence_lettres) = alphabets
  frequence_lettres=sort(frequence_lettres,decreasing = TRUE)
}

textecrypte2=function(texte_crypte, frequence_lettres,frequence_lettres_cryptees){
  lettres_cryptees_ordonnees=names(frequence_lettres_cryptees)
  lettres_ordonnees=names(frequence_lettres)
  texte_crypte2 = ''
  for(i in 1:str_length(texte_crypte)){
    for(j in 1:length(lettres_cryptees_ordonnees)){
      if(str_sub(texte_crypte,i,i)==lettres_cryptees_ordonnees[j]){
    texte_crypte2=str_c(texte_crypte2,lettres_ordonnees[j])
      }
    }
  }
  return(toString(texte_crypte2))
}

choix_texte_voisin=function(texte_crypte,frequences_lettres,alphabets,qualite,matrice_apprentissage,textevoisin,textevoisin2){
  if (qualite(texte_crypte,matrice_apprentissage)!=0){
    return(textevoisin2(texte_crypte,alphabets))
  }
  else if(qualite(texte_crypte,matrice_apprentissage)==0){
return(textevoisin(texte_crypte,frequences_lettres))
  } 
  else(print("erreur in choix_texte_voisin"))
  
}



##apprentissage



generer_rdata=function(nom_fichier_texte_apprentissage,lecture_texte_apprentissage,extraction_alphabets_du_texte,calcul_matrice_apprentissage,frequencelettres,traitement_des_caracteres_speciaux){#Cette fonction genère un fichier .Rdata contenant l'environnement généré lors de l'apprentissage à l'aide du fichier mon_fichier_texte_apprentissage
texte_apprentissage = lecture_texte_apprentissage(nom_fichier_texte_apprentissage)
alphabets = extraction_alphabets_du_texte(texte_apprentissage)
matrice_apprentissage = calcul_matrice_apprentissage(texte_apprentissage,alphabets)
frequences_lettres=frequencelettres(texte_apprentissage,extraction_alphabets_du_texte)
lettres_ordonnees=names(frequences_lettres)
lettres_ordonnees = traitement_des_caracteres_speciaux(lettres_ordonnees)
#for(i in (length(lettres_ordonnees)-k):length(lettres_ordonnees)){
#  texte_apprentissage <- gsub(lettres_ordonnees[i],"", texte_apprentissage)
#}
#alphabets = extraction_alphabets_du_texte(texte_apprentissage)
#matrice_apprentissage = calcul_matrice_apprentissage(texte_apprentissage,alphabets)
#frequences_lettres=frequencelettres(texte_apprentissage,extraction_alphabets_du_texte)
nom_fichier_sortie=paste(nom_fichier_texte_apprentissage,".Rdata")
print(paste("le fichier \"",nom_fichier_sortie,"\" a été créé dans le repertoire courant"))
return(save(matrice_apprentissage,alphabets,frequences_lettres,lettres_ordonnees,file=nom_fichier_sortie))
}


##Execution






cryptage_reactive=eventReactive(c(input$go_cryptage),{
  
  input$language
  langue=input$language
   if(langue==2){
      load("francais.Rdata")
      
    }
    
    else if (langue==1){
     load("anglais.RData")
    }
texte=input$texte_a_crypter
texte=str_to_lower(texte)

texte_crypte = cryptage(texte,alphabets)
texte_crypte
})




decryptage_reactive=eventReactive(c(input$go_decryptage),{
input$language
  langue=input$language
   if(langue==2){
      load("francais.Rdata")
      
    }
    
    else if (langue==1){
     load("anglais.RData")
    }

texte_crypte=input$texte_a_decrypter
texte_crypte_initial=texte_crypte
v=c()
texte_crypte=str_to_lower(texte_crypte)
frequences_lettres_cryptees=frequencelettres(texte_crypte,extraction_alphabets_du_texte)
texte_crypte=textecrypte2(texte_crypte,frequences_lettres,frequences_lettres_cryptees)
best=list("",-Inf)
v=c()
n_iterations_metropolis=input$n_iterations_metropolis


 withProgress(message = 'Decryptage', value = 0, {
for(l in 1:n_iterations_metropolis){
  
  texte_voisin=textevoisin(texte_crypte,frequences_lettres)
texte_crypte=metropolis(texte_voisin,texte_crypte,qualite,matrice_apprentissage,frequences_lettres)
p=qualite(texte_crypte,matrice_apprentissage)

  incProgress(1/n_iterations_metropolis, detail = paste("itération ", l,"/",n_iterations_metropolis,"Courant : ","\n",texte_crypte,"\n\n"
   ))

if(p>best[[2]]){best=list(texte_crypte,p)}
if(l%%100==0){
cat("n = ",l,"\n\n")
cat("Courant  : ",p,"\n",texte_crypte,"\n\n")
cat("meilleur : ",best[[2]],"\n",best[[1]],"\n","\n\n\n")


  v=c(v,texte_crypte)
}
}
 })
v=c(v,best[[1]])
return(v)

}) #end decryptage_reactive



output$texte_courant <- renderPrint(decryptage_reactive())
   


output$texte_crypte <- renderText({
    cryptage_reactive()
  })


 output$texte_decrypte <- renderText({
    decryptage_reactive()[length(decryptage_reactive())]
   
  })


output$clip <- renderUI({
    rclipButton("clipbtn", "Copier", cryptage_reactive(), icon("clipboard"))
  })





} #end server



# Run the application 
shinyApp(ui = ui, server = server,   options = list(width= 950, height = 800))
```
