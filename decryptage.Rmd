---
title: "projet2"
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
### Réinitialisation de l'environnement ###
rm(list=ls())

### Librairies ###
library(stringr)

### Paramétres ###
nom_fichier_corpus = 'hamlet.txt'
```

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r fonctions, echo=FALSE}
lecture_corpus <- function(nom_fichier) {
  corpus <- toString(readLines(nom_fichier))
  corpus <- str_to_lower(corpus)
  corpus <- gsub("\\s{2,}"," ", corpus) #Supression des espaces non nécessaires
  corpus <- gsub(" ,","", corpus) #Supression des virgules non nécessaires
  return(corpus)
}


extraction_alphabets <- function(texte) {
  alphabets = c()
  for (i in 1:str_length(texte) ){
    alphabet = str_sub(texte,i,i)
    
    if (!alphabet %in% alphabets)
      alphabets = c(alphabets,alphabet)
  }
  return(alphabets)
}


traitement_regex_caracteres_speciaux <- function(character) {
  if ( str_detect( character , "[\\+\\*\\?\\^\\$\\.\\[\\]\\{\\}\\(\\)\\|\\/]" ) ) {
    character = str_c("\\",character)
  }
  return(character)
}


remplissage_valeur_bigrames <- function(data) {
  alphabets = extraction_alphabets(paste(data[[1]], collapse = ''))

  matrice_bigrames = matrix(1e-10,nrow = length(alphabets), ncol = length(alphabets), byrow = TRUE, dimnames = list(alphabets, alphabets))

  for (compteur in 1:length(data[[1]]) ) {
      lettre_precedente = strsplit(data[compteur,1], NULL)[[1]][1]
      lettre_suivante = strsplit(data[compteur,1], NULL)[[1]][2]
      matrice_bigrames[lettre_precedente,lettre_suivante] = data[compteur,2]
  }
  
  for (numero_ligne in 1:nrow(matrice_bigrames) ) {
    matrice_bigrames[numero_ligne,] = matrice_bigrames[numero_ligne,] / sum(matrice_bigrames[numero_ligne,]) 
  }
  
  return(matrice_bigrames)
}


remplissage_valeur_trigrames <- function(data) {
  alphabets = extraction_alphabets(paste(data[[1]], collapse = ''))

  matrice_trigrames = array(1e-10, dim = c(length(alphabets) , length(alphabets), length(alphabets)) , dimnames = list(alphabets, alphabets,alphabets ))

  for (compteur in 1:length(data[[1]]) ) {
      lettre_anteprecedent = strsplit(data[compteur,1], NULL)[[1]][1]
      lettre_precedente = strsplit(data[compteur,1], NULL)[[1]][2]
      lettre_suivante = strsplit(data[compteur,1], NULL)[[1]][3]
      matrice_trigrames[lettre_anteprecedent,lettre_precedente,lettre_suivante] = data[compteur,2]
  }
  
  for (numero_ligne in 1:nrow(matrice_trigrames) ) {
    for (numero_colonne in 1:ncol(matrice_trigrames) ) {
      matrice_trigrames[numero_ligne,numero_colonne,] = matrice_trigrames[numero_ligne,numero_colonne,] / sum(matrice_trigrames[numero_ligne,numero_colonne,]) 
    }
  }
  
  return(matrice_trigrames)
}


calcule_frequence_bigrames <- function(texte, alphabets) {
  frequence_bigrames = c()
  
  for (i in 1: length(alphabets) ) {
    lettre_precedente = alphabets[i]
    occurences_lettre_precedente = str_extract_all(texte,str_c(traitement_regex_de_caracteres_speciaux(lettre_precedente),'.'))[[1]]
    
    for (j in 1: length(alphabets) ) {
      lettre_suivante = alphabets[j]
      bigrame = str_c(lettre_precedente,lettre_suivante)
      cardinal_bigrame = sum(occurences_lettre_precedente == bigrame)
      frequence_bigrame = cardinal_bigrame/length(occurences_lettre_precedente)
      frequence_bigrames = c(frequence_bigrames, frequence_bigrame)
    }
  }
  
  matrice_bigrames = matrix(frequence_bigrames, nrow = length(alphabets), byrow = TRUE, dimnames = list(alphabets, alphabets) )
  
  valeur_minimal = unique(sort(matrice_bigrames))[2]*1e-3
  matrice_bigrames[matrice_bigrames == 0] <- valeur_minimal
  
  for (numero_ligne in 1:nrow(matrice_bigrames) ) {
    matrice_bigrames[numero_ligne,] = matrice_bigrames[numero_ligne,] / sum(matrice_bigrames[numero_ligne,]) 
  }
  
  return(matrice_bigrames)
}


calcule_frequence_trigrames <- function(texte, alphabets) {
  frequence_trigrames = c()
  
  for (compteur_anteprecendent in 1: length(alphabets) ) {
    lettre_anteprecedente = alphabets[compteur_anteprecendent]
    occurences_lettre_anteprecedente = str_extract_all(texte,str_c(traitement_regex_de_caracteres_speciaux(lettre_anteprecedente),'..'))[[1]]
    
    for (compteur_precedent in 1: length(alphabets) ) {
      lettre_precedente = alphabets[compteur_precedent]
      occurences_lettre_precedente = occurences_lettre_anteprecedente[grepl(str_c('.',traitement_regex_de_caracteres_speciaux(lettre_precedente),'.'), occurences_lettre_anteprecedente, perl = TRUE)]
      
      for (compteur_suivant in 1:length(alphabets)) {
        lettre_suivante = alphabets[compteur_suivant]
        trigrame = str_c(lettre_anteprecedente,lettre_precedente, lettre_suivante)
        cardinal_trigrame = sum(occurences_lettre_precedente == trigrame)
        
        if (cardinal_trigrame != 0) {
          frequence_trigrame = cardinal_trigrame/length(occurences_lettre_precedente)
        } else {
          frequence_trigrame = 0
        }
        frequence_trigrames = c(frequence_trigrames, frequence_trigrame)
      }
    }
  }
  
  matrice_trigrames = array(frequence_trigrames, dim = c(length(alphabets) , length(alphabets), length(alphabets)) , dimnames = list(alphabets, alphabets, alphabets) )
  
  valeur_minimal = unique(sort(matrice_trigrames))[2]*1e-3
  matrice_trigrames[matrice_trigrames == 0] <- valeur_minimal
  
  for (numero_ligne in 1:nrow(matrice_trigrames) ) {
    for (numero_colonne in 1:ncol(matrice_trigrames) ) {
      matrice_trigrames[numero_ligne,numero_colonne,] = matrice_trigrames[numero_ligne,numero_colonne,] / sum(matrice_trigrames[numero_ligne,numero_colonne,]) 
    }
  }
  
  return(matrice_trigrames)
}


calcul_qualite_log = function(texte,matrice_de_selection) {
  qualite = 0
  
  if(is.matrix(matrice_de_selection)) {
    for(compteur in 1:(str_length(texte)-1) ) {
      probabilite_bigrame = matrice_de_selection[ str_sub(texte,compteur,compteur) , str_sub(texte, compteur+1, compteur+1) ]
      qualite = qualite + log(probabilite_bigrame)
    }
      
  } else {
      
    for(compteur in 1:(str_length(texte)-2) ) {
      probabilite_trigrame = matrice_de_selection[ str_sub(texte,compteur,compteur) , str_sub(texte, compteur+1, compteur+1), str_sub(texte, compteur+2, compteur+2) ]
      qualite = qualite + log(probabilite_trigrame)
    }
  }
  return(qualite)
}


cryptage <- function(texte,alphabets) {
  alphabets_crypte = sample(alphabets)
  texte_crypte = c()
  for( i in 1:(str_length(texte)) ) {
    lettre_texte = str_sub(texte,i,i)
    texte_crypte = str_c( texte_crypte , alphabets[ which( lettre_texte == alphabets_crypte) ] )
  }
  return(texte_crypte)
}



calcul_qualite_multiplication = function(texte, matrice_de_selection){
  qualite = 1
  for(compteur in 1:(str_length(texte)-1)){
    qualite = qualite*matrice_de_selection[str_sub(texte,compteur,i),str_sub(texte,compteur+1,compteur+1)]
  }
  return(qualite)
}



##permutation_alphabet = function(alphabets) 
textevoisin=function(texte,frequences_lettres){
  lettres_ordonnees=names(frequences_lettres)
  alphabet_du_texte=extraction_alphabets(texte)
  indice1=sample(length(alphabet_du_texte),size=1)
  indice2=sample(1:length(lettres_ordonnees),size=1,prob=frequences_lettres/sum(frequences_lettres))
  paire_indice=c(indice1,indice2)
  paire_indice
  texte_voisin=''
  for(i in 1:str_length(texte)){
    if(str_sub(texte,i,i)==alphabet_du_texte[paire_indice[1]]){
      texte_voisin=str_c(texte_voisin,toString(lettres_ordonnees[paire_indice[2]]))
      
    }
     else if(str_sub(texte,i,i)==lettres_ordonnees[paire_indice[2]]){
      texte_voisin=str_c(texte_voisin,alphabet_du_texte[paire_indice[1]])
     }
    else{
      texte_voisin=str_c(texte_voisin,str_sub(texte,i,i))
    }
  }
  return(texte_voisin)
}


Q=function(texte_voisin,texte_crypte,proba,matrice_apprentissage,frequences_lettres,n){
  probanew=proba(texte_voisin,matrice_apprentissage)
  probaold=proba(texte_crypte,matrice_apprentissage)
if (probanew-probaold >= 0) { return(texte_voisin) } 
else if (runif(1) < probanew/probaold) { return(texte_voisin) } 
else { return(texte_crypte) }
}



frequencelettres=function(texte,extraction_alphabets_du_texte){
  alphabets=extraction_alphabets(texte)
frequence_lettres=c(numeric(length(alphabets)))
  n=str_length(texte)
    for(i in 1:n){
      print(i)
      for(j in 1:length(alphabets)){
        if(str_sub(texte,i,i)==alphabets[j]){frequence_lettres[j]=frequence_lettres[j]+1}
      }
    }
  names(frequence_lettres) = alphabets
  frequence_lettres=sort(frequence_lettres,decreasing = TRUE)
  print(frequence_lettres)
}



textecrypte2=function(texte_crypte, frequence_lettres,frequence_lettres_cryptees){
  lettres_cryptees_ordonnees=names(frequence_lettres_cryptees)
  print(lettres_cryptees_ordonnees)
  lettres_ordonnees=names(frequence_lettres)
  print(lettres_ordonnees)
  texte_crypte2 = ''
  for(i in 1:str_length(texte_crypte)){
    for(j in 1:length(lettres_cryptees_ordonnees)){
      if(str_sub(texte_crypte,i,i)==lettres_cryptees_ordonnees[j]){
    texte_crypte2=str_c(texte_crypte2,lettres_ordonnees[j])
      }
    }
  }
  return(toString(texte_crypte2))
}


```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r apprentissage, echo=FALSE}
texte_apprentissage = lecture_corpus(nom_fichier_corpus)
alphabets = extraction_alphabets_du_texte(texte_apprentissage)
matrice_apprentissage = calcule_frequence_bigrames(texte_apprentissage,alphabets)
frequences_lettres=frequencelettres(texte_apprentissage,extraction_alphabets_du_texte)
k = 6
lettres_ordonnees=names(frequences_lettres)
lettres_ordonnees = traitement_regex_de_caracteres_speciaux(lettres_ordonnees)
for(i in (length(lettres_ordonnees)-k):length(lettres_ordonnees)){
  texte_apprentissage <- gsub(lettres_ordonnees[i],"", texte_apprentissage)
}
alphabets = extraction_alphabets_du_texte(texte_apprentissage)
matrice_apprentissage = calcule_frequence_bigrames(texte_apprentissage,alphabets)
frequences_lettres=frequencelettres(texte_apprentissage,extraction_alphabets_du_texte)


###Aprentissage langue anglaise###

##bigrames sans espace
#data = read.table('english_bigrams_1.txt', header = FALSE, sep = "", stringsAsFactors = FALSE, col.names = c("syllabe","valeur"), na.strings = "")

##bigrames avec espace
data = read.table("EN-Letterpairs.txt", header = FALSE, sep = '\t', stringsAsFactors = FALSE, na.strings = "", fill = TRUE, skip = 1)[,c(8,2)]
data = data[grepl("([A-Z]|\\s){2,}", data[,1], perl = TRUE),]
names(data) = c("syllabe","valeur")
row.names(data) <- NULL
matrice_de_selection = remplissage_valeur_bigrames(data)


##trigrames avec espace
data = read.table("EN-Lettertriplets.txt", header = FALSE, sep = '\t', stringsAsFactors = FALSE, na.strings = "", fill = TRUE, skip = 1)[,c(8,2)]
data = data[grepl("([A-Z]|\\s){2,}", data[,1], perl = TRUE),]
names(data) = c("syllabe","valeur")
row.names(data) <- NULL
matrice_de_selection = remplissage_valeur_trigrames(data)



```



```{r execution, echo=FALSE}
texte=".i am the and we for of this what then a now "
n=str_length(texte)
texte_crypte = cryptage(texte, alphabets)
frequences_lettres_cryptees=frequencelettres(texte_crypte,extraction_alphabets_du_texte)
texte_crypte=textecrypte2(texte_crypte,frequences_lettres,frequences_lettres_cryptees)
best=list("",0)
for(l in 1:150000){
texte_voisin <- textevoisin(texte_crypte,frequences_lettres)
texte_crypte=Q(texte_voisin,texte_crypte,proba,matrice_apprentissage,frequences_lettres,n)
print(texte_crypte)
print(proba(texte_crypte,matrice_apprentissage))
p=proba(texte_crypte,matrice_apprentissage)
if(p>best[[2]]){best=list(texte_crypte,p)}
print(c("best = ",best[[1]],best[[2]]))
}
```






Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



