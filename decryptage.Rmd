---
title: "projet2"
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
### Réinitialisation de l'environnement ###
rm(list=ls())

### Librairies ###
library(stringr)

### Paramétres ###
nom_fichier_corpus = 'wonderland.txt'
```

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r fonctions, echo=FALSE}
lecture_corpus <- function(nom_fichier) {
  corpus <- toString(readLines(nom_fichier))
  corpus <- str_to_lower(corpus)
  corpus <- gsub("\\s{2,}"," ", corpus) #Supression des espaces non nécessaires
  corpus <- gsub(" ,","", corpus) #Supression des virgules non nécessaires
  return(corpus)
}


extraction_alphabets <- function(texte) {
  alphabets = c()
  for (compteur in 1:str_length(texte) ){
    alphabet = str_sub(texte,compteur,compteur)
    
    if (!alphabet %in% alphabets)
      alphabets = c(alphabets,alphabet)
  }
  return(alphabets)
}



traitement_regex_caracteres_speciaux <- function(character) {
  if ( str_detect( character , "[\\+\\*\\?\\^\\$\\.\\[\\]\\{\\}\\(\\)\\|\\/]" ) ) {
    character = str_c("\\",character)
  }
  return(character)
}



ordonner_alphabets_par_frequence = function(texte, alphabets){
    alphabets_ordonnees = c()
    
    for( alphabet in alphabets ){
     alphabets_ordonnees = c(alphabets_ordonnees ,length(str_extract_all(texte, traitement_regex_caracteres_speciaux(alphabet)) [[1]]) )
  }
  
  names(alphabets_ordonnees) = alphabets
  alphabets_ordonnees = sort(alphabets_ordonnees,decreasing = TRUE)
  
  return(alphabets_ordonnees)
}



remplissage_valeur_bigrames <- function(data) {
  alphabets = extraction_alphabets(paste(data[[1]], collapse = ''))

  matrice_bigrames = matrix(1e-10,nrow = length(alphabets), ncol = length(alphabets), byrow = TRUE, dimnames = list(alphabets, alphabets))

  for (compteur in 1:length(data[[1]]) ) {
      bigram = strsplit(data[[1]][compteur], NULL)[[1]]
      lettre_precedente = bigram[1]
      lettre_suivante = bigram[2]
      matrice_bigrames[lettre_precedente,lettre_suivante] = data[[2]][compteur]
  }
  
  for (numero_ligne in 1:nrow(matrice_bigrames) ) {
    matrice_bigrames[numero_ligne,] = matrice_bigrames[numero_ligne,] / sum(matrice_bigrames[numero_ligne,]) 
  }
  
  return(matrice_bigrames)
}


remplissage_valeur_trigrames <- function(data) {
  alphabets = extraction_alphabets(paste(data[[1]], collapse = ''))

  matrice_trigrames = array(1e-10, dim = c(length(alphabets) , length(alphabets), length(alphabets)) , dimnames = list(alphabets, alphabets,alphabets ))

  for (compteur in 1:length(data[[1]]) ) {
      trigrame = strsplit(data[[1]][compteur], NULL)[[1]]
      lettre_anteprecedent = trigrame[1]
      lettre_precedente = trigrame[2]
      lettre_suivante = trigrame[3]
      matrice_trigrames[lettre_anteprecedent,lettre_precedente,lettre_suivante] = data[[2]][compteur]
  }
  
  for (numero_ligne in 1:nrow(matrice_trigrames) ) {
    for (numero_colonne in 1:ncol(matrice_trigrames) ) {
      matrice_trigrames[numero_ligne,numero_colonne,] = matrice_trigrames[numero_ligne,numero_colonne,] / sum(matrice_trigrames[numero_ligne,numero_colonne,]) 
    }
  }
  
  return(matrice_trigrames)
}


calcule_frequence_bigrames <- function(texte, alphabets) {
  frequence_bigrames = c()
  
  for (compteur_precedent in 1: length(alphabets) ) {
    lettre_precedente = alphabets[compteur_precedent]
    occurences_lettre_precedente = str_extract_all(texte,str_c(traitement_regex_caracteres_speciaux(lettre_precedente),'.'))[[1]]
    
    for (compteur_suivant in 1: length(alphabets) ) {
      lettre_suivante = alphabets[compteur_suivant]
      bigrame = str_c(lettre_precedente,lettre_suivante)
      cardinal_bigrame = sum(occurences_lettre_precedente == bigrame)
      frequence_bigrame = cardinal_bigrame/length(occurences_lettre_precedente)
      frequence_bigrames = c(frequence_bigrames, frequence_bigrame)
    }
  }
  
  matrice_bigrames = matrix(frequence_bigrames, nrow = length(alphabets), byrow = TRUE, dimnames = list(alphabets, alphabets) )
  
  valeur_minimal = unique(sort(matrice_bigrames))[2]*1e-3
  matrice_bigrames[matrice_bigrames == 0] <- valeur_minimal
  
  for (numero_ligne in 1:nrow(matrice_bigrames) ) {
    matrice_bigrames[numero_ligne,] = matrice_bigrames[numero_ligne,] / sum(matrice_bigrames[numero_ligne,]) 
  }
  
  return(matrice_bigrames)
}


calcule_frequence_trigrames <- function(texte, alphabets) {
  frequence_trigrames = c()
  
  for (compteur_anteprecendent in 1: length(alphabets) ) {
    lettre_anteprecedente = alphabets[compteur_anteprecendent]
    occurences_lettre_anteprecedente = str_extract_all(texte,str_c(traitement_regex_caracteres_speciaux(lettre_anteprecedente),'..'))[[1]]
    
    for (compteur_precedent in 1: length(alphabets) ) {
      lettre_precedente = alphabets[compteur_precedent]
      occurences_lettre_precedente = occurences_lettre_anteprecedente[grepl(str_c('.',traitement_regex_caracteres_speciaux(lettre_precedente),'.'), occurences_lettre_anteprecedente, perl = TRUE)]
      
      for (compteur_suivant in 1:length(alphabets)) {
        lettre_suivante = alphabets[compteur_suivant]
        trigrame = str_c(lettre_anteprecedente,lettre_precedente, lettre_suivante)
        cardinal_trigrame = sum(occurences_lettre_precedente == trigrame)
        
        if (cardinal_trigrame != 0) {
          frequence_trigrame = cardinal_trigrame/length(occurences_lettre_precedente)
        } else {
          frequence_trigrame = 0
        }
        frequence_trigrames = c(frequence_trigrames, frequence_trigrame)
      }
    }
  }
  
  matrice_trigrames = array(frequence_trigrames, dim = c(length(alphabets) , length(alphabets), length(alphabets)) , dimnames = list(alphabets, alphabets, alphabets) )
  
  valeur_minimal = unique(sort(matrice_trigrames))[2]*1e-3
  matrice_trigrames[matrice_trigrames == 0] <- valeur_minimal
  
  for (numero_ligne in 1:nrow(matrice_trigrames) ) {
    for (numero_colonne in 1:ncol(matrice_trigrames) ) {
      matrice_trigrames[numero_ligne,numero_colonne,] = matrice_trigrames[numero_ligne,numero_colonne,] / sum(matrice_trigrames[numero_ligne,numero_colonne,]) 
    }
  }
  
  return(matrice_trigrames)
}


calcul_qualite_multiplication = function(texte,matrice_de_selection) {
  qualite = 1
  
  if(is.matrix(matrice_de_selection)) {
    for(compteur in 1:(str_length(texte)-1) ) {
      qualite = qualite*matrice_de_selection[str_sub(texte,compteur,compteur) , str_sub(texte,compteur+1,compteur+1)]
    }
      
  } else {
      
    for(compteur in 1:(str_length(texte)-2) ) {
      qualite = qualite*matrice_de_selection[str_sub(texte,compteur,compteur) , str_sub(texte, compteur+1, compteur+1), str_sub(texte, compteur+2, compteur+2)]
    }
  }
  
  return(qualite)
}



calcul_qualite_log = function(texte,matrice_de_selection) {
  qualite = 0
  
  if(is.matrix(matrice_de_selection)) {
    for(compteur in 1:(str_length(texte)-1) ) {
      probabilite_bigrame = matrice_de_selection[ str_sub(texte,compteur,compteur) , str_sub(texte, compteur+1, compteur+1) ]
      qualite = qualite + log(probabilite_bigrame)
    }
      
  } else {
      
    for(compteur in 1:(str_length(texte)-2) ) {
      probabilite_trigrame = matrice_de_selection[ str_sub(texte,compteur,compteur) , str_sub(texte, compteur+1, compteur+1), str_sub(texte, compteur+2, compteur+2) ]
      qualite = qualite + log(probabilite_trigrame)
    }
  }
  return(qualite)
}



permutation_des_lettres_par_unifome = function (alphabets) {
  
  indice_lettre_1 = sample(length(alphabets), size = 1)
  indice_lettre_2 = sample(length(alphabets), size = 1)
  
  lettre_1 = alphabets[indice_lettre_1]
  lettre_2 = alphabets[indice_lettre_2]
  
  lettres_a_permuter=c(lettre_1,lettre_2)

  return(lettres_a_permuter)
}



permutation_des_lettres_par_frequence = function (alphabets_ordonnees) {
  
  indice_lettre_1 = sample(length(alphabets_ordonnees), size = 1)
  indice_lettre_2 = sample(1:length(alphabets_ordonnees), size = 1, prob = alphabets_ordonnees/sum(alphabets_ordonnees))
  
  lettre_1 = toString(names(alphabets_ordonnees[indice_lettre_1]))
  lettre_2 = toString(names(alphabets_ordonnees[indice_lettre_2]))
  
  lettres_a_permuter=c(lettre_1,lettre_2)

  return(lettres_a_permuter)
}



decryptage_texte_par_permutation_2_lettres = function(texte,lettres_a_permuter){
  texte_decrypte = ''
  for(i in 1:str_length(texte)){
    if(str_sub(texte,i,i) == lettres_a_permuter[1]) {
        texte_decrypte = str_c(texte_decrypte,lettres_a_permuter[2])
        
     } else if (str_sub(texte,i,i) == lettres_a_permuter[2]) {
        texte_decrypte = str_c(texte_decrypte, lettres_a_permuter[1])
        
     } else {
        texte_decrypte = str_c(texte_decrypte,str_sub(texte,i,i))
    }
  }
  return(texte_decrypte)
}



decryptage_par_frequence_alphabets = function(texte_crypte,alphabets_matrice_selection_ordonnees){
  
  alphabets_texte_crypte = extraction_alphabets(texte_crypte)
  alphabets_texte_crypte_ordonnees = names(ordonner_alphabets_par_frequence(texte_crypte, alphabets_texte_crypte))
  
  texte_decrypte = ''
  for(i in 1:str_length(texte_crypte)){
    for(j in 1:length(alphabets_texte_crypte_ordonnees)){
      if(str_sub(texte_crypte,i,i) == alphabets_texte_crypte_ordonnees[j]){
        texte_decrypte = str_c(texte_decrypte, alphabets_matrice_selection_ordonnees[j])
      }
    }
  }
  return(texte_decrypte)
}



algo_metropolis = function(texte_decrypte_etape_precedent,texte_decrypte_etape_suivant,calcul_qualite,matrice_de_selection) {
   qualite_texte_precendent = calcul_qualite(texte_decrypte_etape_precedent, matrice_de_selection)
   qualite_texte_suivant = calcul_qualite(texte_decrypte_etape_suivant, matrice_de_selection)
   
   if (qualite_texte_suivant >= qualite_texte_precendent) {
        return(texte_decrypte_etape_suivant)
     } else if (qualite_texte_precendent > 0 && runif(1) < qualite_texte_suivant/qualite_texte_precendent) { 
        return(texte_decrypte_etape_suivant)
     } else if ( runif(1) < exp(qualite_texte_suivant - qualite_texte_precendent) ) {
        return(texte_decrypte_etape_suivant)
     } else {
        return(texte_decrypte_etape_precedent)
   }
}



cryptage <- function(texte,alphabets) {
  alphabets_crypte = sample(alphabets)
  texte_crypte = c()
  
  for( i in 1:(str_length(texte)) ) {
    lettre_texte = str_sub(texte,i,i)
    texte_crypte = str_c( texte_crypte , alphabets[ which( lettre_texte == alphabets_crypte) ] )
  }
  
  return(texte_crypte)
}



selection_lettres_alphabets_corpus = function(corpus,alphabets_corpus_initiale,nombre_de_lettre_a_garder) {
  alphabets_corpus_ordonnees = names(ordonner_alphabets_par_frequence(corpus,alphabets_corpus_initiale))
  
  for (compteur in nombre_de_lettre_a_garder:length(alphabets_corpus_ordonnees) ){
    corpus <- gsub(traitement_regex_caracteres_speciaux(alphabets_corpus_ordonnees[compteur]),"", corpus)
  }
  alphabets_corpus = extraction_alphabets(corpus)
  return(alphabets_corpus)
}
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r matrice de selection, echo=FALSE}

###Calcul matrice de selection d'un corpus###
corpus = lecture_corpus(nom_fichier_corpus)
alphabets_corpus = extraction_alphabets(corpus)

  ##Calcul matrice de selection d'un corpus uniquement avec les lettres les plus frquentes de l'alphabets##
  nombre_de_lettre_a_garder = 40
  alphabets_corpus = selection_lettres_alphabets_corpus(corpus,alphabets_corpus,nombre_de_lettre_a_garder)

matrice_de_selection = calcule_frequence_bigrames(corpus,alphabets_corpus)




###Remplissage de matrice de selection de valeures connues###

##Anglais : bigrames sans espace
data = read.table('english_bigrams_1.txt', header = FALSE, sep = "", stringsAsFactors = FALSE, col.names = c("syllabe","valeur"), na.strings = "")
data[][1] = lapply(data[][1], tolower) #mets les lettres des lignes et colonnes en minuscule
matrice_de_selection = remplissage_valeur_bigrames(data)

##Anglais : bigrames avec espace
data = read.table("EN-Letterpairs.txt", header = FALSE, sep = '\t', stringsAsFactors = FALSE, na.strings = "", fill = TRUE, skip = 1)[,c(8,2)] #choisi les colonnes 8 et 2 du fichier 
data = data[grepl("([A-Z]|\\s){2,}", data[,1], perl = TRUE),] #Ne prends que les lettres entre A et Z de l'alphabets
names(data) = c("syllabe","valeur")
row.names(data) <- NULL  #reordonne les indices de la list apres supression de certaines lignes  
data[][1] = lapply(data[][1], tolower) #mets les lettres des lignes et colonnes en minuscule
matrice_de_selection = remplissage_valeur_bigrames(data)


##Anglais : trigrames avec espace
data = read.table("EN-Lettertriplets.txt", header = FALSE, sep = '\t', stringsAsFactors = FALSE, na.strings = "", fill = TRUE, skip = 1)[,c(8,2)]  #choisi les colonnes 8 et 2 du fichier 
data = data[grepl("([A-Z]|\\s){2,}", data[,1], perl = TRUE),] #Ne prends que les lettres entre A et Z de l'alphabets
names(data) = c("syllabe","valeur")
row.names(data) <- NULL   #reordonne les indices de la list apres supression de certaines lignes  
data[][1] = lapply(data[][1], tolower)  #mets les lettres des lignes et colonnes en minuscule
matrice_de_selection = remplissage_valeur_trigrames(data)


###Aprentissage langue francaise###





```



```{r cryptage, echo=FALSE}
texte=".i am the and we for of this what then a now "
texte_crypte = cryptage(texte, alphabets_corpus)
```



```{r decrytage, echo=FALSE}
alphabets_matrice_selection_ordonnees = ordonner_alphabets_par_frequence(corpus,alphabets)

texte_crypte = decryptage_par_frequence_alphabets(texte_crypte,names(alphabets_matrice_selection_ordonnees))


nombre_iterations_max = 500000

meilleurs_resultats = list("",0)
for(iteration in 1:nombre_iterations_max){
  lettres_a_permuter = permutation_des_lettres_par_frequence(alphabets_matrice_selection_ordonnees)
  texte_decrypte = decryptage_texte_par_permutation_2_lettres(texte_crypte,lettres_a_permuter)
  texte_crypte = algo_metropolis(texte_crypte, texte_decrypte, calcul_qualite_multiplication, matrice_de_selection)
  
  print(texte_crypte)
  print(proba(texte_crypte,matrice_de_selection))
  
  qualite_texte_decrypte = calcul_qualite_multiplication(texte_crypte,matrice_de_selection)
  if (qualite_texte_decrypte > meilleurs_resultat[[2]]) {
    meilleurs_resultats = list(texte_crypte, qualite_texte_decrypte)
  }
  print(c("meilleurs_resultats = ", meilleurs_resultats[[1]], meilleurs_resultats[[2]]))
}

texte_decrypte = meilleurs_resultats[[1]]
```










Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



